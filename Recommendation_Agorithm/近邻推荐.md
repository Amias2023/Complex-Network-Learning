# 1. 协同过滤
  > 协同过滤的核心是用户物品关系矩阵

* 1. 基于记忆的协同过滤
> 记住消费过的物品，推荐相似的东西，或者推荐相似的人的消费的东西

* 2. 基于模型的协同过滤
> 从用户物品关系矩阵中学习一个模型，从而把矩阵的空白处填满


-------


# 2. 基于用户的协同过滤

* 1. 准备用户向量
    * 向量的纬度是物品的数量
    
* 2. 使用用户向量，计算两两用户之间的相似度，设定一个相似度阈值，

* 3. 为每一个用户产生推荐结果
  > 聚类相似的用户喜欢的用品汇总起来，去掉用户已经消费过的物品，剩下的排序 就是推荐结果

计算公式：
<div align="center"> <img src="" width="400"/> </div><br>

* P 是计算每一个物品 和用户之间的匹配分数

* 分母是 把和用户u相似的n个用户的相似度加起来

* 分子 是： n 个用户对商品的态度 按照相似度加权平均。





### 1. 构造矩阵

协同过滤计算，使用的矩阵是稀疏的，稀疏矩阵的典型储存格式

* 1. CSR 整体编码 = 数值 列号 行偏移
* 2. COO 每个元素使用三元组表示 （行号，列号，数值）

### 2. 相似度计算

1. 向量很长--降低计算复杂度

* 1. 对向量采样计算--- Twitter ： DIMSUM算法 ；在Spark中实现

* 2. 向量话计算  ： 避免循环，转换成向量


2. 用户量很大，两两之间的计算代价很大

* 1. 相似度计算拆分成 Map Reduce 任务，将原始矩阵成建为 用户对， 值为两个用户对同一个物品分评分之积

* 2. 数据量不超过百万，矩阵稀疏， 单机工具： KGraph， GraphCHI



### 3. 推荐计算

**计算过程拆分成Map Reduce 任务**--- 使用多线程技术实现Map的效果： C++ 的 OpenMP 库，使用多线程。

具体拆分：

* 1. 遍历每个用户喜欢的物品列表

* 2. 获取该 用户的相似性用户列表

* 3. 把每一个喜欢的物品 Map 成两个记录发射出去，一个是键为 < 相似用户 ID，物品 ID，1> 三元组，可以拼成一个字符串，值为 < 相似度 >，
另一个是键为 < 相似用户 ID，物品 ID，0> 三元组，值为 < 喜欢程度 * 相似度 >，其中的 1 和 0 为了区分两者

* 4. Reduce 阶段，求和后输出；

* 5. < 相似用户 ID，物品 ID, 0> 的值除以 < 相似用户 ID，物品 ID, 1> 的值


### 4. 改进

> 改进集中在 用户对物品的喜欢程度上

* 1. 惩罚对热门物品的喜欢程度， 热门的东西很难反应用户端额真是兴趣，无聊随便点击，群体行为常见特点

* 2. 增加喜欢程度的时间衰减，使用一个指数函数，指数是一个负数



# 3. 基于物品的协同过滤

1. 物品的数量少于用户的数量；

2. 物品之间的相似度 静态，变化的速度没有用户的口味变化快

3. 计算物品之间相似度稀疏度是好过计算用户之间的相似度的


* 计算步骤

1.  构建用户物品的关系矩阵，  ： 用户的消费行为，消费后的评价，消费行为的量化： 时间，次数，费用

2.  计算得到物品相似度的矩阵

3.  产生推荐结果



 ### 1. 计算物品之间的相似度
 
 
 * 物品向量： 稀疏向量，纬度是用户， 各个纬度的取值是，对这个物品的消费结果，行为本身的布尔值
 
 * 两两计算物品的相似度 ： 余弦相似度
 
 
 改进物品之间的相似度
 
 * 1. 物品中心化，
 > 计算 每一个
 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

















